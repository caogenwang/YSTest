1. 查询语句写的烂

2. 索引失效
    （1）单值索引
        select * from user where name='';
        create index inx_user_name on user(name);
    （2）符合索引   
        select * from user where name='' and email='';

3. 关联太多的join

4. 服务器调优及各个参数

5.常见的join查询
    (1)SQL的执行顺序
        手写：
            SELECT DISTINCT
                <select_list>
            FROM
                <left_type> <join_type>
            JOIN <right_table> ON <join_condition>
            WHERE
                <where_condition>
            GROUP BY
                <group_by_list>
            HAVING
                <having_condition>
            ORDER_BY
                <order_by_conditon>
            LIMIT <limit number>
    （2）
        1. 内连接
            SELECT <select_list>
            FROM TableA A
            INNER JOIN TableB B
            ON A.key= B.key
        2. 左连接
            SELECT <select_list>
            FROM TableA A
            LEFT JOIN TableB B
            ON A.key= B.key
        3. 右连接
            SELECT <select_list>
            FROM TableA A
            RIGHT JOIN TableB B
            ON A.key= B.key
        4. 左连接 - 共同部分
            SELECT <select_list>
            FROM TableA A
            LEFT JOIN TableB B
            ON A.key = B.key
            WHERE B.key IS NULL
        5. 右连接 - 共同部分
            SELECT <select_list>
            FROM TableA A
            RIGHT JOIN TableB B
            ON A.key = B.key
            WHERE A.key IS NULL
        6. 全连接
            SELECT <select_list>
            FROM TableA
            FULL OUTER JOIN TableB B
            ON A.key = B.key
        7. 全连接 - 共同部分
            SELECT <select_list>
            FROM TableA
            FULL OUTER JOIN TableB B
            ON A.key = B.key
            WHERE A.key IS NULL 
            OR B.key IS NULL

6. 索引是帮助MySql高效获取数据的数据结构,索引的本质是数据结构。
    索引的目的在于提高查询效率，可类比字典。
    可以理解为 排好序的快速查找数据结构。
    
    两个功能：查找快，排好序

    会影响where和order_by后边的查找效率。
    
    在数据之外，数据库系统还维护这满足特定查找算法的数据结构，这些数据结构以某种方式
    引用数据。
    这样就可以在这些数据上实现高级算法查找，这种数据结构就是索引。

    BTREE

    物理地址   索引地址
    0x00        10
    0x07        20                二叉树存储索引(可以使用高级算法)
    0x14        80
    0x18        90
    0x20        100

    可以维护一个右边所示的二叉查找树，每个节点分别包含索引建和一个指向对应数据
    记录物理地址的地址，这样可以运用二叉查找树在一定的复杂度内获取到相应数据，
    从而快速的检索出符合条件的记录。

    索引一般存储在磁盘上，也有一部分存放在内存中。

    索引的优势：
                提高检索效率，降低数据库的IO成本。
                降低数据排序成本，降低的CPU的消耗。
    索引的劣势：
                索引也是一张表，保存了主键和索引字段，并指向实体表的记录，索引索引列也是
                要占用空间的。

                虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT，UPDATE，
                DELETE。因为更新表时，MySQL不进要保存数据，还要保存一下索引文件每次更新添加了
                索引列的字段，都会调整因为更新所带来的的jian'zhi'bian'hua
    
    花时间建立最优秀的锁，不停的优化建立索引。

7. 索引的分类：
    （1）单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。
    （2）唯一索引：索引列的值必须唯一，但允许有空值。
    （3）复合索引：即一个索引包含多个列
    （4）基本语法：
            创建：   CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))
                    ALTER mytable ADD [UNIQUE] INDEX [indexName] ON (columnname(length))
            删除：  DROP INDEX [indexName] ON mytable

            查看： SHOW INDEX FROM table_name\G    
8. mysql索引的结构：
    （1）BTREE索引：
    （2）Hash索引：
    （3）

9. 建立索引的情况：
    （1）主键自动创建索引。
    （2）频繁作为查询条件的字段应该创建索引。
    （3）查询中与其他表关联的字段，外键建立索引。
    （4）频繁更新的字段不适合创建索引。
    （5）where用不到的字段不用创建索引。
    （6）单键/组合索引的选择问题，（高并发下倾向创建组合索引）。
    （7）查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度。
    （8）查询中统计或者分组字段。

10. 不需要建立索引的情况：
    （1）表记录太少。
    （2）经常增删改的字段。
    （3）数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。
        某个表中许多数据重复，不需要为他建立索引值。

11.性能分析
    （1）查询优化器：
    （2）CPU：cpu在饱和的时候一般发生在数据装入内存或者从磁盘上读取数据。
    （3）IO：磁盘IO瓶颈发生在装入数据远大于内存容量的时候。
    （4）服务器硬件的性能瓶颈：top，free，iostat，vmstat来查看系统的性能状态。

12. Explain：
    使用explain关键字可以模拟优化器执行SQL查询语句，从而知道Mysql是如何处理你的sql语句的。分析你的查询语句
    或者表结构的性能瓶颈。

    mysql> explain select * from boys bo left join beauty be on bo.id = be.boyfriend_id where be.boyfriend_id is null;
    +----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                              |
    +----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
    |  1 | SIMPLE      | bo    | ALL  | NULL          | NULL | NULL    | NULL |    5 | NULL                                               |
    |  1 | SIMPLE      | be    | ALL  | NULL          | NULL | NULL    | NULL |   12 | Using where; Using join buffer (Block Nested Loop) |
    +----+-------------+-------+------+---------------+------+---------+------+------+----------------------------------------------------+
        1 row in set (0.03 sec)
    表的读取顺序：
    数据读取操作的操作类型：
    哪些索引可以使用：
    哪些索引被实际使用：
    表之间的引用：
    每张表有多少行被优化器查询：
    1. id： （1）select查询的序列号，包含一组数字，表示查询中执行select橘子或者操顺序。
        （2）
            1.id相同：查询的顺序由上到下
            2.id不同：如果是子查询，id的序号会递增，id值越大优先级越高越先被执行。
            3.id相同又不同：id大的先执行，相同的id顺序执行。
    
    2. select_type：
        （1）SIMPLE：简单select查询，查询中不包含子查询或者UNION。
        （2）PRIMARY:查询中若包含热河复杂的子部分，最外层查询则被标记为。
        （3）SUBQUERY:在select或者where列表中包含子查询。
        （4）DERIVED:在FROM列表中包含子查询被标记为DERIVED，mysql会递归执行这些子查询，结果放在临时表里
        （5）UNION：若第二个select出现在union之后，则被标记为union，若union包含在from自居的子查询中，外层select将被标记为 DERIVED
        （6）UNION RESULT:从union表获取结果的select。

    3. type:
        从最好到最差依次是：
        syetem > const > eq_ref > ref > range > index > ALL

        system:表只有一行记录，平时不会出现
        const：表示通过索引依次就找到，const用于比较primary unique索引
        eq_ref：唯一索引扫描，对于每个索引建，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描。
        ref:非唯一索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，
            然而，他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。
        range：只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，between and
        index：全索引扫描，index是从索引中读取，all是从硬盘。
        all：全表扫描，效率最低。
    
    4. possible_keys和key
        是否使用了索引，判断是否索引失效。
        possible_keys：显示可能应用在这种表中的索引，一个或多个，查询涉及到的字段上若涉及存在的索引，则索引将被列出
                        ，但不一定被使用。
        key:实际中建立了索引
            覆盖索引：select 后边查询的字段和索引建立的个数和顺序是一致的。
    5. key-len：索引的字节数，长度越短越好，并非实际使用长度，不是通过表内检索得出。

    6. ref：索引被使用，显示索引的哪一列被引用

    7. rows：越小越好

    8. extra：
        十分重要的信息。
        （1）using filesort:说明mysql会对数据使用一个外部的索引进行排序，而不是按照表内的索引顺序进行读取，
                        mysql中无法利用索引完成排序的操作叫做文件排序。
        （2）using temporary:新建了一个临时表，保存中间结果。常见于order_by和group_by
        （3）using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。
                        如果同时出现using where，表明索引被用来执行索引键值查找；
                        如果没有出现using where，表明索引用来读取数据而非执行查找动作。
        （4）using where
        （5）using buffer
        （6）impossible where
        （7）select tables optimized away
        （8）distinct

13. 索引的案例分析：创建索引
    （1）单张表：

    （2）两张表：
        1. 左连接加在右表。
        2. 右连接加在左表。
    （3）三张表：
        select * FROM class LEFT JOIN ON class.card= book.card LEFT JOIN phone ON book.card = phone.card
        1. 还是左连接在右边的表加索引。
        2. 小表驱动大表。
        3. 优先优化NestedLoop的内层循环。
        4. 保证join语句中被驱动的表上join字段已经被索引。
        5. 当无法保证被驱动的表的join条件字段被索引且内存资源充足的前提下，不要太吝啬joinbuffer的设置。
14. 索引失效(应该避免)
    （1）复合索引有顺序要求，最佳左前缀法则。带头大哥不能死，中间兄弟不能断。哈哈
    （2）索引列上少计算。
    （3）范围之后全失效。
    （4）百分like放右边。
    （6）字符串里有引号。

15. 分析性能：
    1. 观察，至少跑一天，看看生产的慢sql情况。
    2. 开启慢查询日志，设置阈值，比如超过5秒的就是慢sql，并将它抓取出来。
    3. explain + 慢sql分析。
    4. show profile
    4. 运维经理，sql数据库参数调优

16.小表驱动大表

17. 慢查询日志
    默认情况下关闭，

18.批量数据脚本

19. show profile 
        分析当前会话中语句执行的资源消耗情况，可以使用mysql调优。保存最近15次的运行结果，默认情况下是关闭的。
        mysql> show profile cpu,block io for query 2;
        +----------------------+----------+----------+------------+--------------+---------------+
        | Status               | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |
        +----------------------+----------+----------+------------+--------------+---------------+
        | starting             | 0.000042 | 0.000000 |   0.000000 |            0 |             0 |
        | checking permissions | 0.000008 | 0.000000 |   0.000000 |            0 |             0 |
        | Opening tables       | 0.000042 | 0.000000 |   0.000000 |            0 |             0 |
        | init                 | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |
        | System lock          | 0.000006 | 0.000000 |   0.000000 |            0 |             0 |
        | optimizing           | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |
        | statistics           | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |
        | preparing            | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |
        | executing            | 2.175352 | 0.000000 |   0.070000 |            0 |             0 |
        | Sending data         | 0.000023 | 0.000000 |   0.000000 |            0 |             0 |
        | end                  | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |
        | query end            | 0.000003 | 0.000000 |   0.000000 |            0 |             0 |
        | closing tables       | 0.000002 | 0.000000 |   0.000000 |            0 |             0 |
        | removing tmp table   | 0.000005 | 0.000000 |   0.000000 |            0 |             0 |
        | closing tables       | 0.000004 | 0.000000 |   0.000000 |            0 |             0 |
        | freeing items        | 0.000048 | 0.000000 |   0.000000 |            0 |             0 |
        | cleaning up          | 0.000011 | 0.000000 |   0.000000 |            0 |             0 |
        +----------------------+----------+----------+------------+--------------+---------------+
        17 rows in set, 1 warning (0.00 sec)
    
20. 全局查询日志，用在测试环境，不能放在生产环境
    永远不要在生产环境开启这个功能。
    set global general_log=1;
    set global log_output='TABLE'
    select * from mysql.general_log;